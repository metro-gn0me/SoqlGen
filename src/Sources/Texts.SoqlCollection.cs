using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using SoqlGen.Models;

namespace SoqlGen.Sources;

internal static partial class Texts
{
    internal const string SoqlCollection = nameof(SoqlCollection);
    private const string Indent = "                        ";

    public static (string? Source, Diagnostic? Diagnostic) GenerateSoqlCollectionSourceAndDiagnostic(
        QueryObject queryObject,
        QueryDictionary queryObjects)
    {
        var (query, diagnostic) = queryObject.GenerateQuery(queryObjects);

        if (query is null)
        {
            return (null, diagnostic);
        }

        var sourceText = $$"""
        // <auto-generated />
        // Generated by SoqlGen

        namespace {{nameof(SoqlGen)}};

        #nullable enable
        #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
        #pragma warning disable CS8601 // Possible null reference assignment
        #pragma warning disable CS8603 // Possible null reference return
        #pragma warning disable CS8604 // Possible null reference argument
        
        public static partial class {{nameof(SoqlCollection)}}
        {
            public static partial class {{queryObject.Key}}
            {
                public static class Model{{GetClassName(queryObject.ClassName)}}
                {
                    public const string Query = "{{query}}";  
                    {{DeserializationMethodImpl(queryObject, queryObjects)}}
                }
            }
        }

        #pragma warning restore CS8618
        #pragma warning restore CS8604
        #pragma warning restore CS8603
        #pragma warning restore CS8601
        """;

        return (sourceText, diagnostic);
    }

    private static string DeserializationMethodImpl(QueryObject queryObject, QueryDictionary queryObjects)
    {
        var classFullName = queryObject.ClassName;
        var className = GetClassName(classFullName);
        var isNullableContext = classFullName.Contains('?');

        return $$"""

                    /// <summary>
                    /// Deserializes a SOQL response from JSON string into an array of {{className}} objects.
                    /// </summary>
                    /// <param name="jsonResponse">The JSON response string from SOQL query</param>
                    /// <returns>Array of deserialized {{className}} objects</returns>
                    public static {{classFullName}}[] DeserializeSoqlResponse(string jsonResponse)
                    {
                        if (string.IsNullOrEmpty(jsonResponse))
                        {
                            return System.Array.Empty<{{classFullName}}>();
                        }

                        using var doc = System.Text.Json.JsonDocument.Parse(jsonResponse);
                        return DeserializeSoqlResponse(doc.RootElement);
                    }

                    /// <summary>
                    /// Deserializes a SOQL response from JsonElement into an array of {{className}} objects.
                    /// </summary>
                    /// <param name="root">The root JsonElement containing the SOQL response</param>
                    /// <returns>Array of deserialized {{className}} objects</returns>
                    public static {{classFullName}}[] DeserializeSoqlResponse(System.Text.Json.JsonElement root)
                    {
                        if (root.ValueKind == System.Text.Json.JsonValueKind.Null || 
                            root.ValueKind == System.Text.Json.JsonValueKind.Undefined)
                        {
                            return System.Array.Empty<{{classFullName}}>();
                        }

                        System.Text.Json.JsonElement records;
                        
                        // Handle both direct array responses and Salesforce-style responses with "records" property
                        if (root.ValueKind == System.Text.Json.JsonValueKind.Array)
                        {
                            records = root;
                        }
                        else if (!root.TryGetProperty("records", out records))
                        {
                            // Fallback: wrap single object in array
                            var jsonArray = new System.Text.Json.Nodes.JsonArray { root };
                            records = System.Text.Json.JsonSerializer.SerializeToElement(jsonArray);
                        }

                        var recordCount = records.GetArrayLength();
                        if (recordCount == 0)
                        {
                            return System.Array.Empty<{{classFullName}}>();
                        }

                        var result = new {{classFullName}}[recordCount];
                        
                        for (var i = 0; i < recordCount; i++)
                        {
                            var record = records[i];
                            result[i] = DeserializeSingleRecord(record);
                        }

                        return result;
                    }

                    /// <summary>
                    /// Deserializes a single record from JsonElement into a {{className}} object.
                    /// </summary>
                    /// <param name="record">The JsonElement representing a single record</param>
                    /// <returns>Deserialized {{className}} object</returns>
                    private static {{classFullName}} DeserializeSingleRecord(System.Text.Json.JsonElement record)
                    {
                        return new()
                        {
                            {{GeneratePropertyAssignments(queryObject, queryObjects)}}
                        };
                    }
        """;
    }

    private static string GeneratePropertyAssignments(QueryObject queryObject, QueryDictionary queryObjects)
    {
        var assignments = queryObject.Fields.Select(field => GeneratePropertyAssignment(field, queryObject, queryObjects));
        return string.Join($",\n{Indent}", assignments);
    }

    private static string GeneratePropertyAssignment(QueryField field, QueryObject parentObject, QueryDictionary queryObjects)
    {
        var soqlPrefix = $"{nameof(SoqlCollection)}.{parentObject.Key}";

        var declaredPropertyType = field.TypeName.TrimEnd('?');
        var elementType = (field.IsCollection && field.CollectionBaseType is not null)
            ? field.CollectionBaseType.TrimEnd('?')
            : declaredPropertyType;

        var isNullable = field.TypeName.EndsWith("?") || !field.TypeName.Contains("System.") && field.TypeName != "string";

        // If elementType is not a generated model, use primitive deserialization
        if (!queryObjects.TryGetValue((elementType, parentObject.Key), out var _))
        {
            var primitiveDeserializer = GetPrimitiveDeserializer(elementType, isNullable);
            var jsonProp = field.FieldName;
            var deserializationCall = $"record.SafeGetValue(\"{jsonProp}\", static e => {primitiveDeserializer})";

            if (field.IsCollection)
            {
                if (declaredPropertyType.EndsWith("[]"))
                {
                    return $"{field.PropertyName} = record.SafeGetArray(\"{jsonProp}\", static e => {primitiveDeserializer}) ?? System.Array.Empty<{elementType}>()";
                }
                return $"{field.PropertyName} = CreateCollectionInstance<{declaredPropertyType}, {elementType}>(record.SafeGetArray(\"{jsonProp}\", static e => {primitiveDeserializer}))";
            }

            return $"{field.PropertyName} = {deserializationCall}";
        }

        // Handle nested objects/collections
        var nestedDeserializer = $"{soqlPrefix}.Model{GetClassName(elementType)}.DeserializeSoqlResponse";

        if (field.IsCollection)
        {
            if (declaredPropertyType.EndsWith("[]"))
            {
                return $"{field.PropertyName} = {nestedDeserializer}(record.SafeGetValue(\"{field.FieldName}\", static e => e)) ?? System.Array.Empty<{elementType}>()";
            }
            return $"{field.PropertyName} = CreateCollectionInstance<{declaredPropertyType}, {elementType}>({nestedDeserializer}(record.SafeGetValue(\"{field.FieldName}\", static e => e)))";
        }

        return $"{field.PropertyName} = {nestedDeserializer}(record.SafeGetValue(\"{field.FieldName}\", static e => e)).FirstOrDefault()";
    }

    private static string GetPrimitiveDeserializer(string typeName, bool isNullable)
    {
        var coreType = typeName.TrimEnd('?');
        var deserializer = coreType switch
        {
            "string" => "e.GetString()",
            "int" or "Int32" => "e.GetInt32()",
            "long" or "Int64" => "e.GetInt64()",
            "bool" or "Boolean" => "e.GetBoolean()",
            "double" or "Double" => "e.GetDouble()",
            "decimal" or "Decimal" => "e.GetDecimal()",
            "float" or "Single" => "e.GetSingle()",
            "DateTime" => "e.GetDateTime()",
            "DateTimeOffset" => "e.GetDateTimeOffset()",
            "Guid" => "e.GetGuid()",
            _ => $"System.Text.Json.JsonSerializer.Deserialize<{coreType}>(e.GetRawText())"
        };

        // Add null-forgiving operator for required properties to suppress warnings
        if (!isNullable && (coreType == "string" || deserializer.Contains("Deserialize")))
        {
            deserializer += "!";
        }

        return deserializer;
    }

    private static string GetClassName(string className) =>
        className.Substring(className.LastIndexOf('.') + 1).TrimEnd('?');

    public static InitializationContext AddSoqlCollectionSource(this InitializationContext ctx)
    {
        var source = $$"""
        // <auto-generated />
        // Generated by SoqlGen
        #nullable enable

        namespace {{nameof(SoqlGen)}};

        public static partial class {{nameof(SoqlCollection)}}
        {
            /// <summary>
            /// Safely extracts a value from a JsonElement by property name. This helper performs a
            /// TryGetProperty on the provided record, handles null/undefined values and guards the extractor
            /// from throwing InvalidOperationException. Generated code calls this to keep deserialization
            /// expressions compact and safe.
            /// </summary>
            internal static T SafeGetValue<T>(this System.Text.Json.JsonElement record, string propName, System.Func<System.Text.Json.JsonElement, T> extractor)
            {
                if (!record.TryGetProperty(propName, out var element))
                {
                    return default!;
                }

                if (element.ValueKind is System.Text.Json.JsonValueKind.Null or System.Text.Json.JsonValueKind.Undefined)
                {
                    return default!;
                }

                try
                {
                    return extractor(element);
                }
                catch (System.InvalidOperationException)
                {
                    return default!;
                }
            }

            /// <summary>
            /// Safely extracts an array from a JsonElement by property name. Returns null if the
            /// property is missing or is not an array. Each element is extracted using the provided
            /// extractor and guarded against InvalidOperationException.
            /// </summary>
            internal static T[]? SafeGetArray<T>(this System.Text.Json.JsonElement record, string propName, System.Func<System.Text.Json.JsonElement, T> extractor)
            {
                if (!record.TryGetProperty(propName, out var element))
                {
                    return null;
                }

                if (element.ValueKind is System.Text.Json.JsonValueKind.Null or System.Text.Json.JsonValueKind.Undefined)
                {
                    return null;
                }

                if (element.ValueKind != System.Text.Json.JsonValueKind.Array)
                {
                    return null;
                }

                var length = element.GetArrayLength();
                var result = new T[length];
                
                for (var i = 0; i < length; i++)
                {
                    try
                    {
                        result[i] = extractor(element[i]);
                    }
                    catch (System.InvalidOperationException)
                    {
                        result[i] = default!;
                    }
                }

                return result;
            }

            /// <summary>
            /// Creates an instance of a collection type from an array of elements.
            /// </summary>
            internal static TCollection CreateCollectionInstance<TCollection, TElement>(TElement[]? elements)
            {
                elements ??= System.Array.Empty<TElement>();
                
                try
                {
                    return (TCollection)System.Activator.CreateInstance(typeof(TCollection), new object[] { elements })!;
                }
                catch
                {
                    // Fallback for collections without array constructor
                    var collection = System.Activator.CreateInstance<TCollection>();
                    if (collection is System.Collections.Generic.ICollection<TElement> genericCollection)
                    {
                        foreach (var element in elements)
                        {
                            genericCollection.Add(element);
                        }
                    }
                    return collection;
                }
            }
        }
        """;

        ctx.AddSource($"{nameof(SoqlCollection)}.g.cs", SourceText.From(source, Encoding.UTF8));
        return ctx;
    }
}
